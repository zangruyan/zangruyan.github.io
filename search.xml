<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html5多媒体-视频]]></title>
    <url>%2F2018%2F08%2F28%2Fhtml5-vedio%2F</url>
    <content type="text"><![CDATA[视频可以认为图像的升级版1语法格式：&lt;video&gt;&lt;/video&gt; 视频的标签属性 src:用于指明视频的资源地址 width:定视频的宽度 height:设定视频的高度。通常宽高控制之一即可 controls:显示控制面板。默认，控制面板不显示 poster=”:海报图片的资源地址”用于设定海报 loop:允许视频循环播放 preload:让视频预加载。 autoplay:让视频自动播放.(当设置了autoplay之后，preload会自动的失效). 视频支持的格式由于版权的缘故，没有一种视频格式是所有浏览器都支持的。如果一个视频内容想让所有的浏览器都支持，那么至少需要两种格式。HTML5将src属性拓展成了一个标签source，source需要嵌套在video标签中，一个video标签中可以嵌套多个source标签，将src属性写在soure标签上。浏览器从上往下依次判断第一个支持的视频格式，作为要播放的视频。 视频控制 视频的属性： .paused: 用于判断视频是否是暂停的，如果视频是暂停的，那么.paused为true；如果视频为播放的，那么.paused为false。只可以读取，不可以设置。 .currentTime:得到当前视频播放的秒数。既可以获取，又可以设置 .duration:得到视频的总长(秒数) .playbackRate:视频的当前速率。1表示正常速率。既可以获取，又可以设置 .muted:读取/设置视频是否处于静音状态。既可以获取，又可以设置 .volume:表示当前音量，1表示最大音量，0表示最小音量。既可以获取，又可以设置 视频的方法： .play(): 播放视频 .pause(): 暂停视频 视频的事件： ended:当视频结束的时候触发]]></content>
      <categories>
        <category>web前端</category>
        <category>html5</category>
      </categories>
      <tags>
        <tag>vedio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[margin常见问题]]></title>
    <url>%2F2018%2F08%2F28%2Fcss-margin%2F</url>
    <content type="text"><![CDATA[块状元素在垂直方向上有重叠现象 父元素和第一个子元素的margin-top出现重叠。如下:原因是：此时div的margin-top是自动的，由于这种情况下，它们会现margin-top重叠的情况，所以父元素与子元素之间，取margin-top大的那个值为准。如下，也会以50px为准。解决方案：给父元素加border给父元素加padding 兄弟之间在垂直方向margin重合：一样，取相邻的margin值大的那个。由于这里margin是相等，所以表现出来就是完全重合的。]]></content>
      <categories>
        <category>web前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border画三角形]]></title>
    <url>%2F2018%2F08%2F28%2Fcss-border%2F</url>
    <content type="text"><![CDATA[border画三角形要想得到一个三角形，可以把其它三边的颜色设置为背景色。如：只要向下的三角形，保留上边框的颜色，把其它的三边设置为背景色。只要向右的三角形，保留左边框的颜色，把其它的三边设置为背景色。 进一步改进：#fff只适用背景也是白色的情况。 这种情况就不行了。所以，我们写成透明色：transparent。边框的粗细决定三角形的大小 。]]></content>
      <categories>
        <category>web前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动float]]></title>
    <url>%2F2018%2F08%2F27%2Fcss-float%2F</url>
    <content type="text"><![CDATA[清除浮动带来的影响 为什么要清除影响?原因它会破坏标准的文档流。 方法一：给父元素加高度如下代码，是一个常见的网页结构：由于ul中的三个li都浮动，这个浮动产生的破坏性，会沿续到.main的身上。所以p标签中的内容就去填空这个浮动产生的空缺。由于“半脱离”的特性，文字不能填到三个菜单的下方，而是在它们的后面摆放。 解决方法是给ul加高度： 方法二：给父元素设置Overflow:hidden此时，不给父级元素明确的高度，而是设置overflow属性。 样式如下： 结构如下：效果如下： 原理：overflow:hidden。效果是如果元素的内容超出了它的尺寸，就会把超出的部分隐藏。这里达到清除浮动的影响的效果，原因是：既然是要超出部分隐藏。我们没有给父元素设置高度，为了比较父元素的高度和内容的高度，就要先算出父元素的高度，所以它就要考虑父元素当中所有子元素的高度，它就会引起浏览器的“重绘”的操作，这个操作就会纠正浮动引起的父元素高度塌陷的问题。 Overflow属性指定如果内容溢出一个元素的框，会发生什么。默认值：visible。可见的。默认效果如下： 取值：visible 默认值。内容不会被修剪，会呈现在元素框之外。hidden 内容会被修剪，并且其余内容是不可见的。scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容 设置hidden后： 设置为scroll后： 方法三：用clear:both清除浮动元素的影响：clear让自己不受上一个浮动元素的影响取值：None | right |left |both 作用：clear 属性规定元素的哪一侧不允许浮动元素。 如：.div{clear:left}.div元素很有个性：它不允许它的左边出现左浮动的元素。如果出现了，自己换行。改变自己，遵守它的规则。 示例：改变自己。建议使用:clear:both; 实际操作如下：这里有一个问题：我们会多出一个完全没有意义的div，我们只是利用它来清除它前面的元素由于浮动而产生的影响。 程序员为了少写这一句，利用css3伪元素after。给父元素添加一个类：12.clearfix:after&#123;content:””;display:block;height:0;overflow:hidden;clear:both;&#125;.clearfix&#123;*zoom:1&#125;; /*照顾ie浏览器低版本&lt;ie8的感受，达到类似的效果*/]]></content>
      <categories>
        <category>web前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm 重启终端失效的解决方法]]></title>
    <url>%2F2018%2F08%2F16%2F20170801-nvm-restart-failure%2F</url>
    <content type="text"><![CDATA[brew安装 我们需要按照上面提供的方法,首先在用户更目录下 创建 .nvm 文件,在终端中输入 mkdir ~/.nvm 然后去编辑你的 bash 配置文件 $HOME/.bashrc ,如果你使用 zsh 那么编辑 $HOME/.zshrc 配置文件,分别是 nano ~/.bashrc 与 nano ~/.zshrc 把下面的内容粘贴进去 通过 brew install nvm 来安装的nvm粘贴此段 export NVM_DIR=~/.nvm 与 source $(brew –prefix nvm)/nvm.sh 最后让你的 shell 配置及时生效,分别是 source ~/.bashrc 与 source ~/.zshrc curl安装 打开终端键入： 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.7/install.sh bash 配置环境变量(已有 .bash_profile) 12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 配置环境变量(无 .bash_profile) 添加 .bash_profile在终端键入 touch ~/.bash_profile 打开 .bash_profile在终端键入 open -e .bash_profile 在 .basn_profile中输入 export NVM_DIR=”$HOME/.nvm” 与 [ -s “$NVM_DIR/nvm.sh” ] &amp;&amp; . “$NVM_DIR/nvm.sh” # This loads nvm 两行代码 运行配置文件,在终端键入 1source ~/.bash_profile 查看配置路径,在终端键入 1$PATH]]></content>
      <categories>
        <category>web前端</category>
        <category>nvm</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node Package Manager[NPM]]]></title>
    <url>%2F2018%2F08%2F15%2F20170803-npm%2F</url>
    <content type="text"><![CDATA[NPM node包管理工具(器)，用来管理和维护项目中所用到的一些第三方的代码 官网：https://npmjs.org/package.json 当前项目／包的说明配置文件，以及其他一些关于当前项目的说明，该文件内必须最少包含下面两个字段 name：包的名称 version: 包的版本 dependencies:可选的 命令 npm 直接输入npm 命令，不带任何的参数和选项的话，那么就可以看到npm的使用说明 npm install &lt;包名&gt;／别名 npm i &lt;包名&gt; 在当前运行该命名的目录下安装指定的软件包，如果该目录下不存在node_modules目录，然后把包安装在当前目录的node_modules下 –save / -S:安装当前包的同时，添加该安装包的信息到当前项目的package.json的directories中 npm init 初始化一个项目，并且自动生成package.js npm uninstall &lt;包名&gt; / npm un &lt;包名&gt; 卸载指定的安装包，如果想同时从dependencies中删除依赖信息的话，可以加上 –save/-S npm update &lt;包名&gt;npm search &lt;包名&gt;本地安装／全局安装 本地安装：把包安装到当前项目目录下（node_nodules） 全局安装：把包安装到当前系统（电脑）的全剧目录下 区别：安装在本地的包，只能该项目以及该项目下的子目录文件才能访问，安装在全局的包，在整个系统下都可以使用]]></content>
      <categories>
        <category>web前端</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（九 - 运算符、对象、循环）]]></title>
    <url>%2F2017%2F10%2F25%2Fjavascript-9%2F</url>
    <content type="text"><![CDATA[运算符 1.赋值运算符 =、+=、-=、*=、/=、%= 2.算数运算符：运算符都只有数字运算的功能，所以在使用的时候，都会把其他类型专程数字。 “+” 1.当加号左右两侧有一位是字符串时，会把另外一侧也转成字符串 2.使用+号时，两边没有字符串时，优先尝试把左右两侧都转成数字，如果不能转换成数字就转换成字符串进行链接。 “-“ “*” “/“ “%”：取模等于求余数【任何数%n = (0 ~ n-1)】 ++ “–” 注意： 1234567var i = 0;alert(i++); //0alert(i); //1var j = 0;j++;alert(j);//1 3.关系运算符 “&lt;”、”&gt;”、”&lt;=”、”&gt;=”、==、!=、===、”!==” -&gt;扩展： == 和 “===”，以及!= 和!==的区别。 “==” 和 !=：会进行隐式类型转换，把左右两侧的数据类型转换成一个的之后，再去比较。 === 和!==：进行比较的时候，也会比较数据类型，数据类型不一样不会进行比较，则判定两边不相等。 4.逻辑运算符 ||：当第一个条件返回true，就结束运行，返回true，如果第一个条件返回false，那再来看第二个条件，如果第二个条件返回true，整体也为true，如果两个条件都为false，则返回false。 &amp;&amp;：当第一个条件返回false，就结束运算，直接返回false。如果第一个条件返回true，那再来看第二个条件，如果第二个条件返回false，整体也返回false，如果两个条件都返回true则返回true； ！：否、取反，把当前的值转换成布尔值，然后取反，返回的结果是布尔值123456789101112131415//条件成立，执行某件事var a = 0;var b = 2;function fn()&#123; alert(1);&#125;(a&lt;b) &amp;&amp; fn();//条件不成立，执行某件事(a &gt; b)||fn();if(a &gt; b) &#123;&#125; else &#123; fn();&#125; 5.三元运算符 判断条件？成立执行的语句:不成立执行的语句 条件成立返回：成立执行的结果 条件不成立返回：不成立执行的结果 123456789101112131415161718192021var a = 10;var b = 12;var c = a &gt; b ? a:b;eg:window.onload = function() &#123; var btn = document.querySelector(&apos;input&apos;); var box = document.querySelector(&apos;#box&apos;); var isHide = true; btn.onclick = function()&#123; /*if(isHide) &#123; box.style.display = &quot;block&quot;; &#125; else &#123; box.style.display = &quot;none&quot;; &#125;*/ //box.style.display = isHide?&quot;block&quot;:&quot;none&quot;; isHide?box.style.display = &quot;block&quot;:box.style.display = &quot;none&quot;; isHide = !isHide; &#125;;&#125;; 6.运算符的优先级 循环 continue 跳出==本次循环==（不能写到三元运算符中） 123456for(var i = 0;i&lt;5;i++)&#123; if(i==3)&#123; continue;//跳出本次循环 &#125; console.log(i);&#125; break 终止==整个循环== 123456for(var i = 0;i&lt;5;i++)&#123; if(i==3)&#123; break; &#125; console.log(i);&#125; break 默认只会终止包着它的循环。123456789101112131415161718for(var i = 0;i&lt;5;i++)&#123; for(var j=0;j&lt;5;j++)&#123; if(i==3&amp;&amp;j==3)&#123; break; &#125; console.log(i,j); &#125;&#125;//终止指定的for循环name:for(var i = 0;i&lt;5;i++)&#123; for(var j=0;j&lt;5;j++)&#123; if(i==3&amp;&amp;j==3)&#123; break name; &#125; console.log(i,j); &#125;&#125; 对象 是一种复杂类型的数据，在对象中我们可以存储任意类型的数据 对象存储数据，是存在对象的属性中 ==对象是没有length这个值的== 属性赋值：obj.key = value; 属性操作： 第一种方式： 读操作：obj.属性名; 写操作：ojb.属性名 = 属性值; obj.key = value;//键值对 第二种方式： 读操作：obj[“属性名”]; 写操作：ojb[“属性值”] = 属性值; obj[“key”] = value;//键值对 **【注意：第二种操作方法[]写的是一个字符串，如果说我们的属性名想要存在变量中，只能用[]这种方式。】** 12345var w = &quot;width&quot;;//注意第一种属性操作是写死的一个值，不能使用变量obj.w，这么写就认为在找obj的属性console.log(obj.w);//第二种属性操作，接受的是一个字符串，字符串就可以存在变量中，可以直接写obj[变量调用]console.log(obj[w]); 循环in运算符 判断这个对象中是否存在该属性，返回的是false或者是true； 12345678910111213var obj = &#123;&#125;;obj[&apos;name&apos;] = &quot;Leo&quot;;obj[&apos;age&apos;] = 40;obj[&apos;gender&apos;] = &quot;female&quot;;obj[&apos;width&apos;] = &quot;180px&quot;;obj[&apos;height&apos;] = &quot;180px&quot;;obj[&apos;children&apos;] = [&quot;大明&quot;,&quot;小明&quot;,&quot;三明&quot;];alert(&quot;name&quot; in obj); // obj 有 name属性就返回 true，否则 返回falsefor (var s in obj) &#123; //通过 in 方法，每次循环的时候把 循环变量s 变成obj对应属性名字 console.log(s,obj[s]);&#125; for in：可以用来循环 对象和数组，不能用来循环一组元素。12345678var arr = [1,4,23];/* for in 可以用来循环 对象和数组,不能用来循环一组元素 for 只能用来循环 数组和类数组(一组元素)*/for (var s in arr) &#123; // 找到 arr上的所有属性,s会依次变成 arr的属性名 console.log(s,arr[s]);// s的类型是字符串&#125; for 只能用来循环 数组和类数组（一组元素）while循环 语法： 12345678910while(判断语句)&#123; 执行语句; 自增;&#125;var i = 0;while(i &lt; 5)&#123; console.log(i); i++;&#125; switch: 语法： 1234567891011121314var a = 15;switch(a) &#123; case 10: // 当 a == 10 console.log(&quot;我想给大家放天假&quot;); break; //a == 10的语句结束之后 添加break case 15: // 当 a == 15 console.log(&quot;当然我就是想想&quot;); break; case 20: // 当 a == 20 console.log(&quot;其实我真正想的是带大家出去玩&quot;); break; default: //以上所有的判断都不成立 console.log(&quot;还是写作业吧&quot;);&#125; 穿刺 1.case成立会把他下边所有的代码都执行了，直到遇到break 2.如果没写鞋break的话，就会形成穿刺现象，把下边所有的代码都执行了。]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>运算符</tag>
        <tag>对象</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（八 - 类型划分）]]></title>
    <url>%2F2017%2F10%2F25%2Fjavascript-8%2F</url>
    <content type="text"><![CDATA[ECMAScript数据类型划分1、标准指定的类型划分： 基本类型： 1.number（数字） 2.string（字符串） 3.undefined（未定义） 4.boolean（布尔值） 5.null（空对象）找不到对象，对象未定义。与非空对象最大区别在于是否能进行属性操作。 对象类型（复合类型）：object(对象)，包含Array;2、typeof的方式划分 typeof是一种运算符，用来查看类型。 1.number:【从负无穷到正无穷的数字及NaN=》not a Number】 Number.POSITIVE_INFINITY 正无穷 Number.NEGATIVE_INFINITY 负无穷 2.string:【字符串，任何包含在引号中的一串字符，都属于字符串】 3.boolean:【true或false两种值，布尔值】 4.object:数组、null、元素对象(Element)、object【注意：空数组不等同于空对象，因为空数组可以进行操作，空对象不能进行属性操作】 1console.log(null == arr); 5.function:函数类型 6.undefined：未定义。 7.NaN：非数字 not a number [类型是number] 1.NaN不等于任何东西，并且不等于它自己。 2.检测一个内容是否是NaN的时候，可以使用isNaN(); 3.数据类型：number; 4.NaN不能用来做比较。 5.isNaN(要检测的内容) return:true/false,isNaN 隐式调用的是Number。 如果转化结果是一个数字就返回false 如果不是一个数字就返回true isNaN会进行隐式类型转换，转换所调用的方法是Number1234var a = Number(&quot;10px&quot;);//NaNvar b = Number(&quot;10px&quot;);//NaN//alert(a == b);// falsealert(isNaN(&quot;$30.2&quot;))//true; 调试： console.log();//只是打印出一个元素或值等。 console.dir();//打印对象。 数据类型的转换。 强制类型转换，或者显示类型转换。 字符串转换数字（强制）： 1.parseInt:取整 (要转换的数字,传进来的数字的进制值) 从左向右一位一位去查看，如果遇到一位是非数字的，结束执行，把这位之前的数字返回 2.parseFloat：转换成小数 (转换为浮点数) 从左向右一位一位的匹配，直到遇到一个非数字（可以匹配一个小数点）就返回这位前边的数字 3.Number(要转换的数字) 从左向右看完所有的字符，如果完全符合数字的规则就转换，如果不符合数字的规则就返回NaN 【注意：关于数组：】 1.空数组转为0；（Number转的方式） 2.数组只有一位的时候，会用这位(代表他本身)去转换，并且只转换数字和字符串为数字的，其他的都是NaN 3.数组有多位的时候，只会被转换为NaN 12345678910111213var num = false;//true = 1;false = 0;var nub;//NaN（undefined）;var nub = null //0;var nub = document; //NaN;var nub = [];//0;var nub = [0];//0;var nub = [10];//10var nub = [10,2];//NaNvar nub = [&apos;aaa&apos;] //NaNvar nub = [&apos;10&apos;]//10var nub = function()&#123;&#125;//NaNvar nub = undefined;//NaNnub = Number(nub); 强制转成字符串 toString();【要转换的内容.toString】 123456var a = 123;a = a.toString(); //将数字123专为字符串类型console.log(a,typeof a);123 string;var b = [&apos;&apos;,&apos;2&apos;];b = b.toString();console.log(b,typeof b);//,2 string String(要转换的内容) 强制转成布尔值 Boolean（要转换的内容） 真：true,非空字符串，非0数字，非空对象。 假：false，空字符串，0，NaN，null，undefined 123!取反alert(!&quot;21323&quot;);//falsealert(Boolean(123));//true 123456var a;if(a)&#123; alert(&quot;真&quot;);&#125; else &#123; alert(&quot;假&quot;);&#125; 隐式类型转换 浏览器自己进行转换，其他类型转换成数字，主要调取Number “+、+=”： 1.当加号左右两侧有一位是字符串时，会把另外一侧也转成字符串 2.使用+号时，两边没有字符串时，优先尝试把左右两侧都转成数字，如果不能转换成数字就转换成字符串进行链接。 “-“、”“、”/“、”%”、”-=”、”=”、”/=”、”%=”：运算符左右两侧转换成数字进行运算： 1234console.log(null + false,0 + function()&#123;&#125;);//0 &quot;0function()&#123;&#125;&quot;var nub = &quot;20px&quot;;//NaNvar nub2 = &quot;30px&quot;;//NaNconsole.log(nub/nub2);//NaN 运算符 关系运算符： || 、 &amp;&amp; 、！ ||：当第一个条件返回true，就结束运行，返回true，如果第一个条件返回false，那再来看第二个条件，如果第二个条件返回true，整体也为true，如果两个条件都为false，则返回false。 &amp;&amp;：当第一个条件返回false，就结束运算，直接返回false。如果第一个条件返回true，那再来看第二个条件，如果第二个条件返回false，整体也返回false，如果两个条件都返回true则返回true； 123456789101112131415//条件成立，执行某件事var a = 0;var b = 2;function fn()&#123; alert(1);&#125;(a&lt;b) &amp;&amp; fn();//条件不成立，执行某件事(a &gt; b)||fn();if(a &gt; b) &#123;&#125; else &#123; fn();&#125; 讲解剖析 【找出数组中最大的值】1234567891011121314151617var arr = [123,1,324,1233,20,-32,100];//定义一个数组var max = 0;//给一个最初比较的值/* 在这里，max可以设置成负无穷,以下是常量。 Number.POSITIVE_INFINITY 正无穷 Number.NEGATIVE_INFINITY 负无穷*///循环数组for(var i = 0; i &lt; arr.length; i++)&#123; //如果max小于arr[i],说明arr[i]比max大，所以把它的值赋给max。 if(max &lt; arr[i])&#123; max = arr[i]; &#125; //返回最大的【也可直接用这种方式】 //max = Math.max(max,arr[i]);&#125;alert(max); 讲解剖析【取模】1234567891011121314151617var list = document.querySelector(&apos;.list&apos;);var colors = [&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;pink&quot;];var inner = &quot;&quot;;// red blue yellowfor(var i = 0; i &lt; 20; i++)&#123; /*第一种方式，比较笨*/ /*if(i%3 == 0)&#123; inner += &apos;&lt;li style=&quot;background:red&quot;&gt;&apos;+i+&apos;&lt;/li&gt;&apos;; &#125; else if(i%3 == 1) &#123; inner += &apos;&lt;li style=&quot;background:blue&quot;&gt;&apos;+i+&apos;&lt;/li&gt;&apos;; &#125; else if(i%3 == 2) &#123; inner += &apos;&lt;li style=&quot;background:yellow&quot;&gt;&apos;+i+&apos;&lt;/li&gt;&apos;; &#125;*/ /*第二种方式，不会有颜色多少的限制，可扩展性比较好，代码量少*/ inner += &apos;&lt;li style=&quot;background:&apos;+colors[i%colors.length]+&apos;&quot;&gt;&apos;+i+&apos;&lt;/li&gt;&apos;;&#125;list.innerHTML = inner; 讲解剖析【复选框】 复选框样式控制选中用==checked==。 改变事件用==onchange==;123456var input = document.querySelectorAll(&apos;input&apos;);for(var i = 0; i &lt; input.length; i++)&#123; input[i].onchange = function()&#123; console.log(this.checked); &#125;;&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（七 - 总结）]]></title>
    <url>%2F2017%2F10%2F25%2Fjavascript-7%2F</url>
    <content type="text"><![CDATA[1.获取元素的方法 获取单个元素： document.getElementById(‘idName’);//只能从document获取 document.querySelector(‘cssSelector’);//可以从父级获取 获取一组元素//都可以从父级获取 document.querySelectorAll(‘cssSelector’); document.getElementsByTagName(‘tagName’); document.getElementsByClassName(‘className’); query和get方法的区别： query方法只会在声明的时候，获取一次。 get方法每次使用的时候，都会获取一次。 2.事件 onload：加载完成之后（只有window、body能加onload事件） onclick：点击事件 onmonuseover 鼠标移入 onmouseout 鼠标移除 3.变量 用来存储数据的一种方式（存值、存址）。 变量声明：var 变量名 = 要存储的具体数据 规则：在那个函数中声明的变量，就只能在这个函数中使用。 4.变量命名 可以使用字母、数字、$、_。 变量名不能以数字开头 驼峰命名：从第二个单词开始首字母大写 常量命名：字母全部大些，每个单词中间用“_”隔开 注意关键字和保留字不能用于变量名 5.函数 匿名函数：没有名字的函数function(){}; 有名字的函数： 函数声明：function name(){ //执行语句 } 函数调用： 事件调用： el.onclick = name; el.onclick = function(){} 直接调用 name(); 6.属性操作 属性的读操作 属性读操作(获取属性值):obj.属性名 属性写操作(获取修改属性值):obj.属性名 = 属性值； 注意问题： 1.clsss不叫class，叫className 1document.getElementById(&apos;div&apos;).className; 2.style 操作的是元素的行间样式 1234&lt;div id=&quot;div&quot; style=&quot;border:#f00 1px solid;&quot;&gt;&lt;div&gt;&lt;script&gt; document.getElementById(&apos;div&apos;).style;&lt;/script&gt; 3.获取src的时候获取到的是绝对路径 4.获取background这类符合样式的时候，火狐（firefox）下可以获取到符合样式中的所有样式而谷歌（chrom）下获取到的只是我们写了的样式 eg:只设置了一个background:color。12345678&lt;div id=&quot;div&quot; style=&quot;background:blue&quot;&gt;&lt;/div&gt;&lt;script&gt; /* *火狐得到的是:blue none repeat scroll 0% 0%; *谷歌得到的是：blue */ document.getElementById(&apos;div&apos;).style.background;&lt;/script&gt; 5.设置了十六进制颜色，但是获取的时候，获取到的是rgb颜色 eg:background:#f60,得到的是rgb(255, 102, 0)1234567&lt;div id=&quot;div&quot; style=&quot;background:#f60&quot;&gt;&lt;/div&gt;&lt;script&gt; /* * 得到的是rgb(255, 102, 0) */ document.getElementById(&apos;div&apos;).style.background;&lt;/script&gt; 6.遇到“-”，删除“-”，首字母大写 eg:background-color =&gt; backgroundColor1234&lt;div id=&quot;div&quot; style=&quot;background:#f60&quot;&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(&apos;div&apos;).style.backgroundColor;&lt;/script&gt; 7.把等号右侧的值赋给左侧 1var sum = 100; 8.cssText获取style中所有的内容 直接修改cssText会覆盖style中的所有内容，如果不想覆盖之前的所有内容，可以直接写style，或者用+=；12345678&lt;div id=&quot;div&quot; style=&quot;background:#f60;&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementById(&apos;div&apos;); //这个时候style=&quot;color:#f00;&quot; div.cssText = &quot;color:#f00;&quot; //这个时候style=&quot;background:#f60;color:#f00;&quot; div.cssText +=&quot;color:#f00;&quot;&lt;/script&gt; 9.cssText = “” 可以直接清空所有的行间样式。 123456&lt;div id=&quot;div&quot; style=&quot;background:#f60;&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementById(&apos;div&apos;); //这个时候style被清空 div.cssText = &quot;&quot;&lt;/script&gt; 10.innerHTML 代表元素中的所有内容 从元素的开标签到闭合标签之间的所有内容，包括元素中的子元素 直接设置元素的innerHTML,或者替换掉之前的所有内容，如果不想替换只是添加内容用+=；12345678910&lt;div id=&quot;div&quot;&gt;&lt;span&gt;aa&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementById(&apos;div&apos;); //&lt;div id=&quot;div&quot;&gt;aaa&lt;/div&gt; div.innerHTML = &quot;aaa&quot; //&lt;div id=&quot;div&quot;&gt;&lt;span&gt;aa&lt;/span&gt;aaa&lt;/div&gt; div.innerHTML += &quot;aaa&quot;&lt;/script&gt; 11.在写left，width等样式时，一定注意加单位 可以给元素设置它本身不具备的属性，这个叫自定义属性。 自定义属性： 1.对象本身不具备的属性（不是标准中规定的属性，而是我们自己设置的） 2.索引中：在实践中，需要知道当前元素是一组元素中第几个的时候，需要使用索引值。 if语句 扩展： 字符串：引号包起来的一串自负 布尔值：true 和 false 运算符： 1.“+”： 如果加号左右两边是数字，执行加法运算。 如果一遍是字符串，执行字符串链接。 2.执行数字运算：“*,/,-,%,–,-=,++,+=” 3.逻辑运算符，返回的结果是布尔值：&gt;,==,&lt;,&gt;=,&lt;=,!=; 4.!非（否） 布尔值中取反 语法: 同一个位置，需要两种或两种以上的执行结果，用判断。 1234567891011121314151617 if(布尔值)&#123;&#125;if(布尔值) &#123;//布尔值为true执行if，为false接着向下执行&#125;else if(布尔值) &#123;&#125;if(布尔值) &#123;&#125; else if(布尔值) &#123;&#125; else &#123;&#125; for循环： 当我们需要同时操作一组元素，或者一组数据的时候需要用到循环。 初始值：var i = 0; 判断条件：i &lt; li.length; 执行语句：执行里面面的操作; 自增：i++; 执行顺序：1，2，3，4 for(初始值;判断条件;自增){ //执行语句 } 数组： 用来存储一组数据 格式[data1,data2,data3] 每一个数据之间用，隔开 一组数据不能直接操作，要操作一位需要使用下标。 需要使用下标 可以从数组length获取到数组中存储多少位数据。 this： 事件函数中 this指向，触发当前事件的元素 目前的非事件函数，this指向window 思路： 定点清除 1.先清楚选中的元素的样式。 2.给当前的元素加上选中样式。 3.定义个变量记录之前选中的元素和当前选中的元素。 自定义属性 大清洗 1.先清除所有元素的选中样式 2.给当前的加上选中样式]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript（六 - 索引）]]></title>
    <url>%2F2017%2F10%2F25%2Fjavascript-6%2F</url>
    <content type="text"><![CDATA[获取方式区分： query相关的方法，再使用时就只获取一次。 get方法在每次我们调用的时候，都会重新获取一次。 onclick清空box.onclick = null//把box的onclick事件变成空对象。 索引 定义一个元素本来不存在的属性，自定义属性。 12345for(var i = 0;i&lt;lis.length;i++)&#123; //自定义属性可以是中文，可以是英文，可以是数字，但是尽量的要使用小写英文字母。 lis[i].序号 = i;&#125; 特定的属性index（索引）。 123456for(var i = 0;i&lt;lis.length;i++)&#123; lis[i].index = i; lis[i].onclick = function()&#123; alert(this.index); &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>onclick</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（简单讲解二）]]></title>
    <url>%2F2017%2F10%2F24%2Fjavascript-1%2F</url>
    <content type="text"><![CDATA[元素获取的其他方法 1.document.querySelector(‘Css Selector’); 接收一个css选择器（通配，群组，包含，id，类…等等 【注意：如果这个选择器对应的是一组元素，就只找到第0个。】 123var box = document.querySelector(&apos;.box&apos;);//第一个var box = document.querySelector(&apos;.box:last-of-type&apos;);//最后一个box.style.background = &quot;red&quot;; 2.父级.querySelectorAll(‘Css选择器’); 获取元素下某个类型的标签 获取结果是一种元素 【注意：一组元素不能在js直接操作,需要添加下标】 3.父级.getElementsByTagName(‘标签名’); 获取元素下某个类型的标签 获取结果是一种元素 4.document.getElementsClassName(‘Class名’); 获取元素下某个类型的标签 获取结果是一种元素 解：一组元素（元素集合，类数组） 一组元素不能直接操作 一组元素哪怕只有一个，它也是一组元素。 一组元素在操作的时候，可以使用下标。 如果需要知道这组元素有几个，可以使用 length属性 if语法 一种操作下会有两种或者以上的执行结果，记得用判断。 123456789101112131415161718if(条件)&#123; 条件成立的时候需要执行的代码&#125;if(条件)&#123; 条件成立的时候需要执行的代码&#125;else&#123; 条件不成立的时候需要执行代码&#125;if(条件一)&#123; 条件一成立的时候需要执行的代码&#125;else if(条件二)&#123; 条件二成立的时候需要执行的代码&#125;....else&#123; 以上条件都不成立的时候执行的代码&#125; 【style提取的是行间样式，所以不建议大家直接使用style里的内容当作判断条件】 运算符 逻辑运算符 “==” 等于 “!=” 不等于 “&gt;=” 大于等于 “&lt;=” 小于等于 “&lt;” 小于 “&lt;” 大于 数据类型为了能够更方便的描述和使用，程序通常会把要操作的数据，根据其特性，分成不同的类型进行操作。在javascript中，数据一共可以分成如下七种类型： 简单类型（值） 1234567891011121314151617181920211. Number 由0-9组成的值，还有几个比较特殊的值 a. NaN -&gt;Not a Number b. Infinity-&gt; 无穷的2. String 由一对单引号或双引号包含的内容【单引号双引号需要成对】3. Booleans 用来描述逻辑的真假的，这种类型有且仅有两个值 a. true 表示真 b. false 表示假 【js严格比较大小写字母】 var a = true; a = !a;//a = false; var a = false; a = !a;//a = true;4. Null 用来描述空值，这种类型有且仅有一个值【注意：当我们使用typeof的时候，返回的是‘object’】5. Undefined 用来描述不存在的值，这种类型有且仅有一个值6. Symbol7. function()&#123;&#125; function函数 复杂类型（复合类型、引用类型） object：由7种数据类型组合的类型，object中包含7种类型中的任意类型。 for循环 var i = 0; i &lt; li.length; 执行里面的操作; i++; 易混解析：1234567891011for(var i = 0; i &lt; li.length; i++)&#123; //循环在页面加载完成之后就执行了 li[i].onclick = function()&#123; /* *点击li时执行 *这会循环肯定已经执行完了， *所以在获取i的时候，是循环执行完之后的结果 */ alert(i); &#125;&#125; this 在事件函数中this代表触发当前事件的元素 1234567for(var i = 0; i &lt; li.length; i++) &#123; li[i].onclick = function()&#123; console.log(this,this.innerHTML); //结果是&lt;span&gt;1111&lt;/span&gt; 1111 // 在事件函数中，this代表触发当前事件的元素 &#125;;&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>元素获取</tag>
        <tag>if</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（五 - for循环）]]></title>
    <url>%2F2017%2F10%2F17%2Fjavascript-5%2F</url>
    <content type="text"><![CDATA[for循环 什么时候使用for循环？ 当我们需要同时处理一组数据得时候，就需要使用循环 需要什么？ 起始值 判断条件 执行语句 自增 写法： 123456789for(var i = 0;i&lt;10;i++)&#123; console.log(i);&#125;var i = 0;//i是一个数字变量,循环变量for(i;i&lt;5;i++)&#123; console.log(i);&#125; 当变量的判断条件永远成立得时候，这个循环就会变成一个死循环。 循环变量在for循环结束之后一样调用，不过调用得值是for循环不符合条件之后得值。 当判断条件不成立时，循环就结束了。 this 在事件函数中this代表触发当前事件的元素。 在所有非事件函数中this指向window。 谁调用这个函数，this就指向谁。 函数执行的时候都属于window调用 思路解析 点击当前div，删除其他div的颜色，给当前点击元素换背景。 1.全部清空法： 1当我们在事件中需要知道当前事件的这个元素是一组中的第几个的时候，添加索引值。 2.索引 V字形生成思路 123456789101.获取外面的盒子2.点击事件3.生成五个div4.写变量l,t,w,h,5.判断他是先自增还是先自减6.设置dis值是正负7.判断拐点。9.inner+= 赋值10.innerHTML 赋值。11.设置top和left值。]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（四 - 运算符）]]></title>
    <url>%2F2017%2F10%2F17%2Fjavascript-4%2F</url>
    <content type="text"><![CDATA[运算符 “+”：可以用作连接符，因此当进行加减运算的时候要确保是两个数字类型。 转换方法：可以用*，-，／任何一种运算符进行自动转换。 “-” “*” “÷” 在js中动态添加元素样式的两种方式 行间样式。 给style标签添加innerHTML(但是有优先级的关系) for循环解析：十行十列 先循环十行 再循环十列 i循环执行一次，j循环执行十次。 1234567 for(var i = 0; i &lt; 10; i++)&#123; console.log(&apos;这是第&apos;+i+&apos;行&apos;); // i循序执行一次 j循环会执行10次 for(var j = 0; j &lt; 10; j++) &#123; console.log(&apos;这是第&apos;+j+&apos;列&apos;); &#125;&#125; 计算top值：当前是第n行，n行高 计算left值：当前是第n行，n列高 计算当前是第几个：行数*每行的个数得出这行之前有多少？]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>for</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（简单讲解三 - 数组）]]></title>
    <url>%2F2017%2F10%2F17%2Fjavascript-3%2F</url>
    <content type="text"><![CDATA[数组 数组[] Array是一种数据格式。 数组中，每个数据之间用“,”隔开。 获取数组中的其中一位，需要用下标。 数组的长度 length。 数组中可以存放任意类型的数据,但是一般为了代码的可读性极维护性，我每一个数组中，只存放一种类型的数据。 当判断不大于这个数组的时候可以两种方式。 i&gt;=arr.length-1; i&gt;arr.length123var = [123,&quot;abc&quot;,true,document,function()&#123;&#125;,,&quot;&quot;,[]];console.log(arr[5]); //undefined;console.log(arr.length);//8 练习和作业详细分析： 布局 获取元素，定义变量，定义数组 循环切换和顺序切换的按钮 1.点击切换下面的文字说明。 2.点击加className,去掉另一个的className 循环切换 1.点击左边箭头控制数字一直减，到0的时候回到5. 2.点击右边尖头控制数字一直加，到最大的时候回到0. 3.上面的1/4修改值 4.切换文字描述4.顺序切换 1.点击左边箭头控制数字一直减，到0的时候弹出提示，并且下面的不能点击. 2.点击右边尖头控制数字一直加，到最大的时候弹出提示，并且下面的不能点击. 3.上面的1/4修改值 4.切换文字描述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body&#123; font-family: Arial; &#125; p&#123; margin: 20px 0; padding:0; &#125; input&#123; outline: none; &#125; .wrap&#123; position: relative; width:550px; margin:50px auto 0; &#125; .tab&#123; width:550px; margin:0 auto; text-align: center; background-color: #000; padding:20px 0; &#125; .tab div&#123; width:164px; margin:0 auto; &#125; .tab div::after&#123; content:&quot;.&quot;; display:block; height:0; clear:both; &#125; .tab input&#123; display: inline-block; border-radius: 3px; width: 80px; line-height:20px; margin-left:-1px; border:#fff 1px solid; background: #000; color:#fff; float: left; cursor: pointer; &#125; .tab input.cur&#123; background: #fff; color:#000; &#125; .tab p&#123; color:#ccc; font-size: 13px; &#125; .box&#123; margin: 0 auto; width: 550px; height: 310px; position: relative; &#125; .box input&#123; position: absolute; top: 50%; margin-top:-25px; width: 40px; height: 50px; border: 0; background: none; color:#fff; font-size: 26px; &#125; .box input:hover&#123; background-color: rgba(0,0,0,.4); cursor: pointer; &#125; .box input:nth-of-type(1)&#123; left: 0; &#125; .box input:nth-of-type(2)&#123; right:0; &#125; .box nav&#123; position: absolute; left:0; bottom:0; width:100%; line-height:40px; color: #fff; text-align: center; background-color: rgba(0,0,0,.3); &#125; .box span&#123; position: absolute; width:100%; line-height:45px; text-align: center; top:0; color: #fff; &#125; .mask&#123; position: absolute; display: none; top:0; left:0; width:100%; height:100%; background-color: rgba(255,255,255,0); z-index: 99; &#125; .fixed&#123; width: 300px; height:150px; position: absolute; left:50%; margin-left: -150px; top:50%; margin-top: -75px; background-color:rgba(0,0,0,.8); color:#fff; text-align: center; &#125; .fixed p:nth-of-type(2)&#123; font-size: 12px; &#125; .fixed a&#123; text-decoration: none; color:#fff; font-size: 12px; &#125; .fixed a:nth-of-type(1)&#123; border:#fff 1px solid; padding:5px 15px; &#125; .fixed a:nth-of-type(2)&#123; position: absolute; right:10px; top:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;tab&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;循环切换&quot; class=&quot;cur&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;顺序切换&quot;&gt; &lt;/div&gt; &lt;p&gt;图片可以从最后一张转到第一张循环&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;span&gt;1/4&lt;/span&gt; &lt;input type=&quot;button&quot; value=&quot;&lt;&quot;&gt; &lt;img src=&quot;img/1.jpg&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;&gt;&quot;&gt; &lt;nav&gt;文字描述一&lt;/nav&gt; &lt;/div&gt; &lt;div class=&quot;mask&quot;&gt; &lt;div class=&quot;fixed&quot;&gt; &lt;p&gt;Javascript 提醒&lt;/p&gt; &lt;p&gt;已经到第一张啦～&lt;/p&gt; &lt;a href=&quot;javascript:&quot;&gt;确定&lt;/a&gt; &lt;a href=&quot;javascript:&quot;&gt;X&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; //获取控制循环和顺序的元素 var tab = document.querySelector(&apos;.tab&apos;); var tabP = tab.querySelector(&apos;p&apos;); var tabs = tab.querySelectorAll(&apos;input&apos;); //获取要进行修改处理的元素 var box = document.querySelector(&apos;.box&apos;); var inputs = box.querySelectorAll(&apos;input&apos;); var span = box.querySelector(&apos;span&apos;); var img = box.querySelector(&apos;img&apos;); var navText = box.querySelector(&apos;nav&apos;); //弹出提示框 var mask = document.querySelector(&apos;.mask&apos;); var fixed = document.querySelector(&apos;.fixed&apos;); var fText = fixed.querySelectorAll(&apos;p&apos;)[1]; var fSure = fixed.querySelectorAll(&apos;a&apos;); //创建数组 var arrImg = [&apos;img/1.jpg&apos;,&apos;img/2.jpg&apos;,&apos;img/3.jpg&apos;,&apos;img/4.jpg&apos;]; var arrImgText = [&apos;文字描述一&apos;,&apos;文字描述二&apos;,&apos;文字描述三&apos;,&apos;文字描述四&apos;]; var arrText = [&apos;图片可以从最后一张转到第一张循环&apos;,&apos;图片只能到第一张或者最后一张&apos;]; var srcNum = 0,max = arrImg.length-1,min = 0,isIn = true; tabs[0].onclick = function() &#123; isIn = true; toFunText(); &#125; tabs[1].onclick = function() &#123; isIn = false; toFunText(); &#125; //切换按钮的样式和文字变换 function toFunText()&#123; if(isIn)&#123; tabP.innerHTML = arrText[0]; tabs[0].className = &apos;cur&apos;; tabs[1].className = &apos;&apos;; &#125;else&#123; tabP.innerHTML = arrText[1]; tabs[1].className = &apos;cur&apos;; tabs[0].className = &apos;&apos;; &#125; &#125; //上一张 inputs[0].onclick = function()&#123; srcNum-- ; if(srcNum&lt;min)&#123; if(isIn)&#123; srcNum = max;//循环 &#125;else&#123; srcNum = min; //alert(&apos;这是第一张&apos;); fText.innerHTML = &apos;已经是第一张了哦～&apos;; mask.style.display = &apos;block&apos;; &#125; &#125; img.src = arrImg[srcNum]; navText.innerHTML = arrImgText[srcNum]; span.innerHTML =(srcNum+1)+&apos;/&apos;+arrImg.length; &#125; //下一张 inputs[1].onclick = function()&#123; srcNum++ ; if(srcNum&gt;max)&#123; if(isIn)&#123; srcNum = min;//循环 &#125;else&#123; srcNum = max; fText.innerHTML = &apos;已经是最后一张了哦～&apos;; mask.style.display = &apos;block&apos;; //alert(&apos;这是最后一张&apos;) &#125; &#125; img.src = arrImg[srcNum]; navText.innerHTML = arrImgText[srcNum]; span.innerHTML =(srcNum+1)+&apos;/&apos;+arrImg.length; &#125; //点击关闭提示弹框 fSure[0].onclick=function()&#123; closeFun(); &#125; fSure[1].onclick=function()&#123; closeFun(); &#125; function closeFun()&#123; mask.style.display = &apos;none&apos;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript（简单讲解一）]]></title>
    <url>%2F2017%2F10%2F16%2Fjavascript-init%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你 javascript(JS)的组成？ DOM 文档对象模型 BOM 浏览器对象模型（滚动条之类） [没有标准，也就意味着兼容性不好] ECMAScript 核心(翻译器) javascript(JS)在页面中处理了什么事情？ 特效交互 数据交互 逻辑操作 常见特效的原理 通过js修改元素的css样式，来操作元素的变化。 js可以写在那里？注意：行为(js)，样式（css），结构（html）三者分离 写在标签内部，行间事件【不建议这样写，不容易实现分离】 在标签上通过一些特殊属性，比如onclick，onmouseover等来实现行为的，并且这个行为和当前元素进行了绑定。 12&lt;!--行内js 作用于标签上面--&gt;&lt;button onclick=&quot;alert(123)&quot;&gt;按钮&lt;/button&gt; 写在页面内部专门的script标签中，当浏览器读到script的时候就会解析代码。 123456&lt;button id=&quot;but2&quot;&gt;按钮2&lt;/botton&gt;&lt;script&gt; document.getElementById(&quot;but2&quot;).onclick = function()&#123; alert(&apos;就是这么绑定事件！&apos;); &#125;&lt;/script&gt; 写在外部调用，专门的js文件中【通过src引入】 12&lt;!--外链JS--&gt;&lt;script src=&quot;js/1.js&quot;&gt;&lt;/script&gt; 获取元素 如果要获取的是个id，可以直接写元素的id名[存在浏览器兼容问题] document.getElementById(“idName”); 获取Id 【单、双引号都可以，但是要成对存在】 【翻译：在文档中 获取 元素 通过 ID】 【获取该元素之前，请确保元素已经被解析了】 123456&lt;script&gt; document.getElementById(&quot;but&quot;).onclick = function()&#123; document.getElementById(&quot;div1&quot;).style.width = &quot;200px&quot;; document.getElementById(&quot;div1&quot;).style.height = &quot;200px&quot;; &#125;&lt;/script&gt; 属性操作 属性的读操作(获取元素的属性值) clsss不叫class，叫className 1document.getElementById(&apos;div&apos;).className; style 操作的是元素的行间样式 1234&lt;div id=&quot;div&quot; style=&quot;border:#f00 1px solid;&quot;&gt;&lt;div&gt;&lt;script&gt; document.getElementById(&apos;div&apos;).style;&lt;/script&gt; 获取src的时候获取到的是绝对路径 获取background这类符合样式的时候，火狐（firefox）下可以获取到符合样式中的所有样式而谷歌（chrom）下获取到的只是我们写了的样式 eg:只设置了一个background:color。12345678&lt;div id=&quot;div&quot; style=&quot;background:blue&quot;&gt;&lt;/div&gt;&lt;script&gt; /* *火狐得到的是:blue none repeat scroll 0% 0%; *谷歌得到的是：blue */ document.getElementById(&apos;div&apos;).style.background;&lt;/script&gt; 设置了十六进制颜色，但是获取的时候，获取到的是rgb颜色 eg:background:#f60,得到的是rgb(255, 102, 0)1234567&lt;div id=&quot;div&quot; style=&quot;background:#f60&quot;&gt;&lt;/div&gt;&lt;script&gt; /* * 得到的是rgb(255, 102, 0) */ document.getElementById(&apos;div&apos;).style.background;&lt;/script&gt; 遇到“-”，删除“-”，首字母大写 eg:background-color =&gt; backgroundColor1234&lt;div id=&quot;div&quot; style=&quot;background:#f60&quot;&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(&apos;div&apos;).style.backgroundColor;&lt;/script&gt; 属性的写操作(修改元素的属性值) 【注意： 在写left，width等样式时，一定注意加单位 】 把等号右侧的值赋给左侧 1var sum = 100; cssText获取style中所有的内容 直接修改cssText会覆盖style中的所有内容，如果不想覆盖之前的所有内容，可以直接写style，或者用+=；12345678&lt;div id=&quot;div&quot; style=&quot;background:#f60;&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementById(&apos;div&apos;); //这个时候style=&quot;color:#f00;&quot; div.cssText = &quot;color:#f00;&quot; //这个时候style=&quot;background:#f60;color:#f00;&quot; div.cssText +=&quot;color:#f00;&quot;&lt;/script&gt; cssText = “” 可以直接清空所有的行间样式。 123456&lt;div id=&quot;div&quot; style=&quot;background:#f60;&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementById(&apos;div&apos;); //这个时候style被清空 div.cssText = &quot;&quot;&lt;/script&gt; innerHTML 代表元素中的所有内容 从元素的开标签到闭合标签之间的所有内容，包括元素中的子元素 直接设置元素的innerHTML,或者替换掉之前的所有内容，如果不想替换只是添加内容用+=；12345678910&lt;div id=&quot;div&quot;&gt;&lt;span&gt;aa&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementById(&apos;div&apos;); //&lt;div id=&quot;div&quot;&gt;aaa&lt;/div&gt; div.innerHTML = &quot;aaa&quot; //&lt;div id=&quot;div&quot;&gt;&lt;span&gt;aa&lt;/span&gt;aaa&lt;/div&gt; div.innerHTML += &quot;aaa&quot;&lt;/script&gt; 字符串 一种数据格式，引号包起来的一串字符 undefined 一种数据类型，未定义 +号运算符 加法运算 链接两个字符串 +=（a += b — a = a + b） 加号有两个作用 一个是加法运算 一个是字符串链接：只有加号左右两侧是数字的情况才会执行加法运算，如果有一侧是字符串就会执行字符串链接，结果也是字符串。 1234var a = &quot;哈哈哈&quot;;var b = 1000;console.log(a+b);//哈哈哈1000console.log(b+a);//1000哈哈哈 变量 变量就相当于给数据起了一个简短的名字 变量的作用：为了方便数据的复用和维护，我们通常用一个东西存放这类数据，我们就把它称为变量。 变量声明 var 变量名 = 要存储的具体数据 变量命名： 以字母开始 变量在命名时最好带有含义 注意不能使用关键字和保留字 驼峰方式命名 不能以数字、特殊符号（除了$,_）开头 后续内容不能包含特殊符号（除了$,_）1234567891011&lt;button id=&quot;but&quot;&gt;按钮1&lt;/button&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script&gt; var but1 = document.getElementById(&apos;but&apos;); var div1 = document.getElementById(&apos;div1&apos;); btn1.onclick = function()&#123; div1.style.width = &quot;200px&quot;; div1.style.height = &quot;200px&quot;; div1.innerHTML = &quot;您好！&quot;； &#125;&lt;/scirpt&gt; 函数 有名字的函数函数声明：function name(){ 要执行的内容}调用:name(); 匿名函数【不能直接使用，只能使用在事件中】 eg:btn1.onclick = function{要执行的内容} 函数调用：把函数执行一遍 事件调用 btn.onclick = name;[注意不加括号] 非事件调用：添加括号 【*注意：btn.onclick = name(); 只会直接执行一次，当点击btn的时候就不执行了；】 【*注意：btn.onclick = function(){name()}; 不直接执行，当点击btn的时候执行；】 什么时候加括号，什么时候不加括号？ 1.当浏览器直接读到这行代码的时候，就执行需要给函数调用加（）； 2.当某种特定的条件下才执行，不需要加（）； window和window.onload onload事件 加载完成 onmouseover和onmouseout 鼠标移入和移出 调试工具： alert()【弹出对话框，接受的是一个字符串】 console.log【打印控制台】 控制台 F12，或者右键-&gt;审查元素方式可以打开调试工具 选择：console 可以通过console进行数据输出，分析，代码调试 123456789101112&lt;button id=&quot;btn&quot;&gt;按钮1&lt;/button&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script&gt; var div1 = document.getElementById(&apos;div1&apos;); var div1 = document.getElementById(&apos;div1&apos;); btn1.onclick = function()&#123; //把信息以日志方式打印到控制台中 console.log(&quot;你好&quot;); //打印数据信息结构 console.dir(div1); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>属性</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化]]></title>
    <url>%2F2017%2F08%2F09%2F20170809-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1.系统模块：http、querystring、url- Crypto 加密 - Events 事件 - Net 网络操作 - OS 操作系统信息 - Path 处理文件路径 - Stream 流操作 - Timers 定时器 - ZLIB 压缩 2.自定义模块- 引入自己的模块必须加./ - 对外输出东西——必须加给exports 12345678910//一个个的exports.xxx=??;exports.xxx=??;exports.xxx=??;//module用来输出一个集合module.exports=&#123; xxx:??, xxx:??, xxx:??&#125;; - 使用 - require——引入其他模块； require(./)； .js可以省略 - 1.如果有&quot;./&quot; 从当前目录找 - 2.如果没有&quot;./&quot; 先从系统模块,再从node_modules找 - exports——输出 - module——批量输出 3.包管理器 npm：NodeJS Package Manager(NodeJS包管理器) 1.统一下载途径 2.自动下载依赖 npm install xxx npm uninstall xxx node_modules——模块必须放在node_modules里面 ./ 不加./ 上传自己的模块 npm init npm publish npm –force unpublish]]></content>
      <categories>
        <category>后端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 用 n 升级 node]]></title>
    <url>%2F2017%2F08%2F09%2Fmac-node-up%2F</url>
    <content type="text"><![CDATA[切记要按照步骤: 第一步，先查看本机node.js版本：$ node -v 第二步，清除node.js的cache：$ sudo npm cache clean -f 第三步，安装 n 工具，这个工具是专门用来管理node.js版本的，别怀疑这个工具的名字，是他是他就是他，他的名字就是 “n”: $ sudo npm install -g n 第四步，安装最新版本的node.js $ sudo n stable:(安装最新稳定版本) $ sudo n latest:(安装最新版本) 第五步，再次查看本机的node.js版本：$ node -v 【注意：第二步比较重要，有些可以省略有些就不行，所以还是使用的好。】]]></content>
      <categories>
        <category>后端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 初识]]></title>
    <url>%2F2017%2F08%2F09%2F20170809-node1%2F</url>
    <content type="text"><![CDATA[http—协议 request 请求 输入-请求的信息 response 响应 输出-输出的东西 1234567891011121314151617const http = require(&apos;http&apos;);var server = http.createServer((req,res) =&gt; &#123; switch (req.url)&#123; case &apos;/1.html&apos;: res.write(&apos;one.html&apos;); break; case &apos;/2.html&apos;: res.write(&apos;two.html&apos;); break; default: res.write(&apos;404&apos;); break; &#125; res.end();&#125;);server.listen(&apos;8080&apos;); 模块 (fs) 文件操作：fs—File System 异步 vs 同步 异步——多个操作可以同时进行，前一次的操作没完事，后一次也能开始 同步——一次一个 读取文件 1readFile(文件名, function (err, data)&#123;&#125;) 写入文件 1writeFile(文件名, 内容, function (err)&#123;&#125;) 请求方式： GET 数据在url中 POST 数据不在url中123req.url=&gt;&quot;/aaa?user=blue&amp;pass=123456&quot;/aaauser=blue&amp;pass=123456 GET数据解析 1.自己切 123456789101112const http = require(&apos;http&apos;);let server = http.createServer((req,res)=&gt;&#123; let Get = &#123;&#125;; var arr = req.url.split(&apos;?&apos;)[1]; var arr2 = arr.split(&apos;&amp;&apos;); for(var i = 0;i&lt;arr2.length;i++)&#123; var arr3 = arr2[i].split(&apos;=&apos;); Get[arr3[0]] = arr3[1]; &#125; console.log(Get);&#125;).listen(&apos;8080&apos;); 2.querystring：xxx=xx&amp;xxx=xxx 12345678910111213const http = require(&apos;http&apos;);const queryString = require(&apos;querystring&apos;);let server = http.createServer((req,res)=&gt;&#123; var GET = &#123;&#125; if(req.url.indexOf(&apos;?&apos;)!=-1)&#123; var arr = req.url.split(&apos;?&apos;); var url = arr[0]; GET=queryString.parse(arr[1]); &#125;else&#123; var url = req.url; &#125; console.log(url,GET);&#125;).listen(&apos;8080&apos;); 3.urlLib：aaa?xxx=xx&amp;xx=12 123456789const http = require(&apos;http&apos;);const urlReq = require(&apos;url&apos;);let server = http.createServer((req,res)=&gt;&#123; var obj = urlReq.parse(req.url,true); var url = obj.pathname; var GET = obj.query; console.log(url,GET);&#125;).listen(&apos;8080&apos;); POST数据 数据接收 req.on(‘data’,function(){}); req.on(‘end’,function(){});1234567891011const http = require(&apos;http&apos;);http.createServer((req,res)=&gt;&#123; var str = &apos;&apos;; req.on(&apos;data&apos;,function(data)&#123; str += data; &#125;); req.on(&apos;end&apos;,function()&#123; console.log(str); &#125;);&#125;).listen(8080); Ajax post get12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function json2url(json)&#123; var arr=[]; for(var name in json)&#123; arr.push(name+&apos;=&apos;+json[name]); &#125; return arr.join(&apos;&amp;&apos;);&#125;function ajax(json)&#123; json=json || &#123;&#125;; if(!json.url)return; json.data=json.data || &#123;&#125;; json.type=json.type || &apos;get&apos;; var timer=null; //低版本的IE浏览器不支持ActiveXObject(&apos;Microsoft.XMLHTTP&apos;) if(window.XMLHttpRequest)&#123; var oAjax=new XMLHttpRequest(); &#125;else&#123; var oAjax=new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125; //配置请求参数 switch(json.type)&#123; case &apos;get&apos;: oAjax.open(&apos;GET&apos;,json.url+&apos;?&apos;+json2url(json.data),true); //3.发送请求 oAjax.send(); break; case &apos;post&apos;: oAjax.open(&apos;POST&apos;,json.url,true); oAjax.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); oAjax.send(json2url(json.data)); break; &#125; /* * 4. 监听返回 * onload属性是标准的XMLHttpRequest才有的事件 * 低版本浏览器不支持 * 低版本浏览器支持的事件 * onreadystatechange * 属性：readyState * ajax的工作状态 * 0：初始化 * 1：调用send方法后（请求发出以后） * 2：请求已经被接收处理 * 3：客户端接收到响应，但是内容还不一定完成了解析 * 4：解析完成 * */ oAjax.onreadystatechange=function()&#123; if(oAjax.readyState==4)&#123; clearTimeout(timer); if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; json.success &amp;&amp; json.success(oAjax.responseText); &#125;else&#123; json.error &amp;&amp; json.error(oAjax.status); &#125; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm常用命令]]></title>
    <url>%2F2017%2F08%2F01%2F20170801-nvm-node%2F</url>
    <content type="text"><![CDATA[nvm常用命令： nvm install ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4 nvm uninstall ## 删除已安装的指定版本，语法与install类似 nvm use ## 切换使用指定的版本node nvm ls ## 列出所有安装的版本 nvm ls-remote ## 列出所以远程服务器的版本（官方node version list） nvm current ## 显示当前的版本 nvm alias ## 给不同的版本号添加别名 nvm unalias ## 删除已定义的别名 nvm reinstall-packages ## 在当前版本node环境下，重新全局安装指定版本号的npm包]]></content>
      <categories>
        <category>web前端</category>
        <category>nvm</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（字符串的扩展）]]></title>
    <url>%2F2017%2F07%2F31%2Fes6-string-extension%2F</url>
    <content type="text"><![CDATA[模版字符串 es6新增的用于表示字符串的语法格式 以``作为模板字符串的起始和结束符 是一个增强的字符串标识符 保持编辑格式 支持表达式 ${表达式} 我们可以把一个js的表达式放置在一个${}中，这里的表达式会被js所解析，注意：不支持语句，比如if，for，while等123456789var str = &apos;muban&apos;;var str1 = `muban`;var str2 = `$&#123;1+2&#125;&lt;ul&gt; &lt;li&gt;$&#123;&apos;muban&apos;.toUpperCase()&#125;&lt;/li&gt; &lt;li&gt;$&#123;str1&#125;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;`console.log(str2);]]></content>
      <categories>
        <category>web前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（函数扩展）]]></title>
    <url>%2F2017%2F07%2F31%2Fes6-function-extension%2F</url>
    <content type="text"><![CDATA[函数参数的默认值 函数参数的默认值：为函数形参设置默认值 语法：123//有默认值的参数写在后面function fn(a,b=1)&#123;&#125;function fn(&#123;a,b=1&#125;)&#123;&#125; 注意：定义默认值的参数必须是尾参数，因为定义默认值之后该参数可忽略。12345function fn(a,b)&#123; return &#123;a,b&#125;;&#125;console.log(fn(1,2));//a =1;b=2;console.log(fn(1));//a=1;b=undefined; 剩余参数 rest参数：用于获取函数的多余参数 我们通常会一个函数定义一些参数，有些参数是确定的，而有些参数是不确定（个数）的 es6之前如果要获取不定参数，一般用anguments不定参来处理 这里用剩余参数来处理 语法：function fn(a,b=1,….变量名){} 注意：rest 后边不能再有其他参数，否则会报错。1234function fn(a,b,c,....tutu)&#123; console.log(tutu);//用于获取函数的多余参数 tutu是个数组&#125;fn(1,2,3,4,5,6,7) 箭头函数：【属于表达式函数】 用来作为回调函数使用。 写法 123456789101112131415161718192021//当参数只有一个的时候 小括号可以省略var f = a=&gt;a+1;//当参数有多个的时候,要加小括号var f = (a,b) =&gt;a+b;//当没有参数时候,也要加小括号var f = () =&gt;a+b;//只有一条语句的时候，可以省略&#123;&#125;，同时该条语句的返回值var fn7 = r =&gt;r * r * Math.PI;//但是如果有多条语句或者返回值是一个对象，则必须使用&#123;&#125;var fn8 = () =&gt;&#123; var result = r * r * Math.PI; console.log(result);&#125;var fn9 = () =&gt;&#123; return &#123; x:10 &#125;&#125; 注意 1、箭头函数的this永远指向 声明时候 作用域的对象 普通函数this指向取决于调用 箭头函数this指向取决于声明 2、不可以当作构造函数，不可以使用new命令，否则会抛出一个错误。 3、该函数体内不存在arguments。]]></content>
      <categories>
        <category>web前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（数组扩展）]]></title>
    <url>%2F2017%2F07%2F28%2Fes6-array-extension%2F</url>
    <content type="text"><![CDATA[扩展运算符（spread） 扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。 1234567var arr = [1,2,3,4,5,6,7];console.log(Math.max(...arr));//7 返回最大值var arr1 = [1,3,4];var arr2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];//var arr3 = arr1.concat(arr2);var arr3 = [...arr1,...arr2] // 1,3,4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;; 数组推导 ES6提供简洁写法，允许直接通过现有数组生成新数组，这被称为数组推导（array comprehension）。 eg:123var arr = [1,2,3,4,5];var arr2 = [for(value of arr) value*2];console.log(arr2);//2,4,6,8,10]]></content>
      <categories>
        <category>web前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（for of）]]></title>
    <url>%2F2017%2F07%2F28%2Fes6-for-of%2F</url>
    <content type="text"><![CDATA[ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。 for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 arr.keys():用于for of对数组键名的遍历 语法：for(let index of arr.keys()){} arr.values():用于for of 对数组键值的遍历 语法：for(let value of arr.values()){} arr.entries():用于for of 对数组键值对的遍历 语法：for(let[index,ele]of arr.entries()){} 回顾： for in 用来遍历对象的属性名。1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];for (var v in arr) &#123; console.log(v);&#125; 数组类似数组的对象，Set，Map 数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器。1234var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];for (var v of arr) &#123; console.log(v); //a,b,c&#125; 普通对象 像var a = {‘a’,’b’}这种普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用，那就要自己设置迭代器12345678910111213141516171819202122232425262728293031323334353637383940// 当我们通过forof去迭代obj的时候，js内部会去查找并调用obj的Symbol.iterator的方法//obj[Symbol.iterator]() =&gt; iterator.next() =&gt; 根据返回的对象中的done值，来决定是否已经完成或继续调用next，如果done为真，表示迭代结束通过忽略这次value值，如果为false，表示当前value有效，并继续下一次迭代（next()）for (var v of obj) &#123; console.log(v);&#125;for (var &#123;k,v&#125; of obj) &#123; console.log(k,v);&#125;例如：自己写迭代器//如果我们希望一个对象能够被迭代，那么就需要去实现该对象的迭代协议和迭代器// 迭代协议var obj = &#123;x:10,y:20,z:100&#125;obj[Symbol.iterator] = function() &#123; //let keys = [&apos;x&apos;, &apos;y&apos;]; let keys = Object.keys(obj); let n = -1; return &#123; next() &#123; if (n &lt; keys.length-1) &#123; //return &#123;done: false, value: obj[keys[n++]]&#125;; //return &#123;done: false, value: keys[n++]&#125;; n++; return &#123;done: false, value: &#123; k: keys[n], v: obj[keys[n]] &#125;&#125;; &#125; else &#123; return &#123;done: true&#125;; &#125; &#125; &#125;&#125;;var objIterator = obj[Symbol.iterator]();//console.log(objIterator);console.log(objIterator.next());console.log(objIterator.next());console.log(objIterator.next());]]></content>
      <categories>
        <category>web前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>for of</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（变量、常量、解构赋值）]]></title>
    <url>%2F2017%2F07%2F27%2Fes6-let-const-Destructuring-assignment%2F</url>
    <content type="text"><![CDATA[变量：let：用来声明变量。【特性】： 不允许重复声明 没有预解析，必须在声明之后使用【我们把当前作用域最开始到let声明的变量之间的区域称为-暂存死区】 块级作用域 一对{}包括的区域称为代码块：块级作用域指一个变量或者函数只在该区域才起作用。 常量：什么是常量？在定义之后值是固定不变的，即为常量。 const作用用来声明常量，注意：重复声明会报错。 变量和常量的区别：变量在定值之后可以修改值，常量不可以，但是常量的对象的值是可以修改的。 常量不可以改，它的子数据可以修改 如果希望一个对象本身及其子数据都不能变化，那么通过const和freeze同时使用123456789eg： const a = &#123;x:0&#125;; a = 12; //错误 a.x = 10; // 可以修改成功 //如果不允许修改，那么就可以用冻结对象的方式 Object.freeze(obj); a.x = 120; console.log(a); // 改不了，因为已经冻结了 解构赋值： ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为结构。 数组的解构赋值 按照对应的顺序解构 123var arr = [1,2,3]var [a,b,c] = arr;console.log(a,b,c); //答案：1 2 3 123var arr = [1,[2,3]];var [a,b,c] = arr;console.log(a,b,c); //1 [2,3] undefind 对象的解构赋值： 根据名称来找的 1.声明{}中的变量 2.根据{}中的变量，去=后面的对象中提取对应的属性，并把该属性对应的值赋值给前面对应的变量，如果没有该属性，返回undefined 3.如果我们希望解构出来的属性名在使用的时候使用的是另一个名称，那么这个时候需要给需要使用的变量名设置一个别名12//取出left别名L，去除top别名Tlet &#123;left:L,top:T,a&#125;=getComputedStyle(document.body); 123456789var obj = &#123; foo:function()&#123; &#125;, o:&#123;&#125;, arr:[], str:&apos;abc&apos;&#125;var &#123;foo,arr,str&#125; = obj;console.log(foo,arr,str);//function()&#123;&#125; [] abc object 交换值：1234var x = 1;var y = 2;var [x,y] = [y,x];console.log(x,y);//2 1;]]></content>
      <categories>
        <category>web前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>let</tag>
        <tag>const</tag>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（对象的扩展）]]></title>
    <url>%2F2017%2F07%2F27%2Fes6-object-extension%2F</url>
    <content type="text"><![CDATA[属性的简洁表示法: 当一个对象的key和对应的值（必须是一个变量名称）同名的话，那么可以简写成一个key 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。例如：123456function f(x,y)&#123; x++; y++; return &#123;x,y&#125;&#125;console.log(f(1,2));//&#123;x:2,y:3&#125; 方法的简洁表示法：例如：1234567891011121314普通：let obj2 = &#123; a:a, fn:function()&#123; console.log(1); &#125;&#125;es6:let obj3 = &#123; a, fn()&#123; console.log(1); &#125;&#125; 属性名表达式123456var x = &apos;username&apos;;let obj4 = &#123; //x: &apos;motao&apos; //这里的x不会作为变量表达式进行解析 [x]: &apos;motao&apos; //如果把key放在一个[]中，那么[]中的内容将被作为表达式进行解析&#125;console.log(obj4);]]></content>
      <categories>
        <category>web前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6简洁表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 命令]]></title>
    <url>%2F2017%2F07%2F24%2Fgithub-pages-Hexo%2F</url>
    <content type="text"><![CDATA[hexo hexo clean hexo generate hexo deploy 些常用命令： hexo new”postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>